// Copyright 2014 Denis Bernard. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package rand64_test

import (
	"fmt"
	"math/rand"
	"testing"

	"github.com/db47h/rand64"
	"github.com/db47h/rand64/mt19937"
	"github.com/db47h/rand64/splitmix64"
	"github.com/db47h/rand64/xoroshiro"
	"github.com/db47h/rand64/xorshift"
)

const (
	SEED1 = 1387366483214
)

// Short example with single value seeding. Since the PRNG's state is larger
// than 64 bits, it will automatically be filled using values generated by the
// splitmix64 PRNG.
func Example() {
	// create a Rand wrapper around a Source PRNG
	rng := rand64.New(xoroshiro.New128plus())
	// seed the PRNG. Note that the Seed64 method takes a uint64.
	rng.Seed64(SEED1)
	// pull values
	_ = rng.Uint64()
}

func Example_verbose() {
	// simple testing function
	// takes a rand64.Source and gets a bunch of numbers using
	// math.rand and rand64
	testfunc := func(name string, s rand64.Source) {
		fmt.Println(name)
		// Using Rand
		r64 := rand64.New(s)
		for i := 0; i < 4; i++ {
			fmt.Printf(" %d", r64.Uint32())
		}
		fmt.Println("")
		for i := 0; i < 4; i++ {
			fmt.Printf(" %d", r64.Uint64())
		}
		fmt.Println("")
		// Play craps
		for i := 0; i < 10; i++ {
			fmt.Printf(" %d%d", r64.Uintn(6)+1, r64.Uintn(6)+1)
		}
		fmt.Println("")
	}

	// create a new splitmix64 source and seed it before use
	// Typically a non-fixed seed should be used, such as time.Now().UnixNano().
	// Using a fixed seed will produce the same output on every run.
	var s rand64.Source = splitmix64.New(SEED1)

	// pull some numbers
	testfunc("splitmix64", s)

	// test the other PRNGs
	s = xoroshiro.New128plus()
	s.Seed(SEED1)
	testfunc("xoroshiro128+", s)
	s = xorshift.New128plus()
	s.Seed(SEED1)
	testfunc("xorshift128+", s)
	s = xorshift.New1024star()
	s.Seed(SEED1)
	testfunc("xorshift1024*", s)

	// since rand64.Rand implements rand.Source, it can
	// be used to proxy a Source to rand.Rand
	fmt.Println("Proxy for math/rand.Rand")
	r := rand.New(rand64.New(s))
	for i := 0; i < 4; i++ {
		fmt.Printf(" %d", r.Int63())
	}
	fmt.Println("")

	// Output:
	// splitmix64
	//  3722461525 4244558569 1281009483 2743734001
	//  17122890372596060995 10712954004355841206 7224747883285011119 13654335654535104829
	//  32 33 13 44 23 66 44 32 63 55
	// xoroshiro128+
	//  3672052799 3619036596 1817626404 4154021231
	//  13508242557925574888 11509836612120350102 17607668528363997996 9787171209907982739
	//  13 64 44 22 66 61 16 46 22 43
	// xorshift128+
	//  3672052799 2300942069 2356831912 2316732845
	//  5560898047753517047 9806550241747869425 16344204150069124721 7133254478284829050
	//  64 11 26 14 23 64 23 23 13 52
	// xorshift1024*
	//  3332849200 1164738618 456220800 3523432244
	//  10311270752396438174 3766918502733849924 15396074446274990069 15679784721060022461
	//  36 33 14 53 43 46 16 66 61 33
	// Proxy for math/rand.Rand
	//  8307002403806671045 2041967637359636555 2088934487125395476 7936776852298221278
}

/* Benchmarks */

func BenchmarkXoroshiro128plus(b *testing.B) {
	s := xoroshiro.New128plus()
	s.Seed(SEED1)
	for i := 0; i < b.N; i++ {
		_ = s.Uint64()
	}
}

func BenchmarkXorShift128plus(b *testing.B) {
	s := xorshift.New128plus()
	s.Seed(SEED1)
	for i := 0; i < b.N; i++ {
		_ = s.Uint64()
	}
}

func BenchmarkXorShift1024star(b *testing.B) {
	s := xorshift.New1024star()
	s.Seed(SEED1)
	for i := 0; i < b.N; i++ {
		_ = s.Uint64()
	}
}

func BenchmarkSplitmix64(b *testing.B) {
	s := splitmix64.New(SEED1)
	for i := 0; i < b.N; i++ {
		_ = s.Uint64()
	}
}

func BenchmarkMt19937(b *testing.B) {
	s := mt19937.New()
	s.Seed(SEED1)
	for i := 0; i < b.N; i++ {
		_ = s.Uint64()
	}
}

func BenchmarkGoRand(b *testing.B) {
	s := rand.NewSource(SEED1)
	for i := 0; i < b.N; i++ {
		_ = s.Int63()
	}
}
